%% Copyright (c) 2018, Jabberbees SAS

%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.

%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

%% @author Emmanuel Boutin <emmanuel.boutin@jabberbees.com>

-module(ecucumber_ct).

-export([
  generate_source/2
]).

-define(TAB, <<"  ">>).
-define(NL, <<"\n">>).

generate_source(Filename, Options) ->
    case egherkin:parse_file(Filename) of
    {failed, Line, Error} ->
        {error, {gherkin, Line, Error}};
    Feature ->
        OutputFilename = ct_suite_filename(Filename, Options),
        generate_ct_suite(OutputFilename, Filename, Feature)
    end.

ct_suite_filename(Filename, Options) ->
    OutputSrcDir = proplists:get_value(output_src_dir, Options, "./test"),
    Basename = filename:basename(Filename, ".feature"),
    filename:join(OutputSrcDir, "feature_" ++ Basename ++ "_SUITE.erl").

generate_ct_suite(Filename, SourceFilename, Feature) ->
    {AllCode, TestCaseCode} = generate_testcases(Feature),
    Source = [
        generate_header(SourceFilename, Filename),
        generate_ct_callbacks(Feature),
        AllCode,
        TestCaseCode
    ],
    file:write_file(Filename, Source).

generate_header(SourceFilename, Filename) ->
    [
        <<"% this file was generated by ecucumber">>, ?NL,
        <<"% from: ">>, SourceFilename, ?NL,
        ?NL,
        <<"-module(">>, filename:basename(Filename, ".erl"), <<").">>, ?NL,
        <<"-compile(export_all).">>, ?NL,
        ?NL,
        <<"-include_lib(\"common_test/include/ct.hrl\").">>, ?NL,
        ?NL
    ].

generate_ct_callbacks(Feature) ->
    FeatureName = egherkin_feature:name(Feature),
    {ModList, TagList} = parse_tags(egherkin_feature:tag_names(Feature)),
    {SetupN, Setup} = generate_mod_calls(<<"setup">>, 0, ModList),
    {CleanupN, Cleanup} = generate_mod_calls(<<"cleanup">>, 0, lists:reverse(ModList)),
    [
        <<"init_per_suite(Config) ->">>, ?NL,
        ?TAB, s(0), <<" = ecucumber_ct_context:enter_feature(">>, b(FeatureName), <<", Config),">>, ?NL,
        Setup,
        ?TAB, s(SetupN), <<".">>, ?NL,
        ?NL,
        <<"end_per_suite(Config) ->">>, ?NL,
        ?TAB, s(0), <<" = ecucumber_ct_context:leave_feature(Config),">>, ?NL,
        Cleanup,
        ?TAB, s(CleanupN), <<".">>, ?NL,
        ?NL,
        <<"init_per_testcase(_TestCase, Config) ->">>, ?NL,
        ?TAB, <<"Config.">>, ?NL,
        ?NL,
        <<"end_per_testcase(_TestCase, Config) ->">>, ?NL,
        ?TAB, <<"Config.">>, ?NL,
        ?NL,
        <<"feature_mods() ->">>, ?NL,
        ?TAB, a(ModList), <<".">>, ?NL,
        ?NL,
        <<"feature_tags() ->">>, ?NL,
        ?TAB, a(TagList), <<".">>, ?NL,
        ?NL
    ].

generate_testcases(Feature) ->
    Scenarios = egherkin_feature:scenarios(Feature),
    TestCases = lists:map(fun generate_testcase/1, Scenarios),
    {Names, Code} = lists:unzip(TestCases),
    AllCode = [
        <<"all() -> [">>, ?NL,
            [[?TAB, Name, ?NL] || Name <- Names],
        <<"].">>, ?NL,
        ?NL
    ],
    {AllCode, Code}.

generate_testcase(Scenario) ->
    Name = egherkin_scenario:name(Scenario),
    TestCaseName = atom_source(Name),
    {ModList, TagList} = parse_tags(egherkin_scenario:tag_names(Scenario)),
    Steps = egherkin_scenario:steps(Scenario),
    {N1, SetupSrc} = generate_mod_calls(<<"setup">>, 0, ModList),
    {N2, StepsSrc} = generate_steps(N1, Steps),
    {N3, CleanupSrc} = generate_mod_calls(<<"cleanup">>, N2, lists:reverse(ModList)),
    Source = [
        TestCaseName, <<"(Config) ->">>, ?NL,
        ?TAB, <<"Tags = feature_tags() ++ ">>, a(TagList), <<",">>, ?NL,
        ?TAB, <<"Mods = feature_mods() ++ ">>, a(ModList), <<",">>, ?NL,
        ?TAB, s(0), <<" = ecucumber_ct_context:enter_scenario(">>, b(Name), <<", Tags, Config),">>, ?NL,
        SetupSrc,
        StepsSrc,
        CleanupSrc,
        ?TAB, <<"ecucumber_ct_context:leave_scenario(">>, s(N3), <<"),">>, ?NL,
        ?TAB, <<"ok.">>, ?NL,
        ?NL
    ],
    {TestCaseName, Source}.

generate_mod_calls(Function, Start, ModList) ->
    Code = [
        [?TAB, s(I+1), <<" = ">>, Mod, <<":">>, Function, <<"(">>, s(I), <<"),">>, ?NL]
        || {I, Mod} <- zipn(Start, ModList)
    ],
    {Start+length(ModList), Code}.

generate_steps(Start, Steps) ->
    {_, Code} = lists:foldl(fun({I, {_, GWTAB, StepParts}}, {LastGWT, Src}) ->
        GWT = case GWTAB of
        and_keyword -> LastGWT;
        but_keyword -> LastGWT;
        _ -> GWTAB
        end,
        PartsSrc = io_lib:format("~p", [StepParts]),
        StepSrc = [
            ?TAB, s(I+1), <<" = ecucumber_ct_context:execute_step_def(">>, ?NL,
            ?TAB, ?TAB, atom_to_binary(GWT, latin1), <<", ">>, ?NL,
            ?TAB, ?TAB, PartsSrc, <<", ">>, ?NL,
            ?TAB, ?TAB, <<"Mods, ">>, s(I), <<"),">>, ?NL
        ],
        {GWT, [StepSrc | Src]}
    end, {undefined, []}, zipn(Start, Steps)),
    {Start+length(Steps), lists:reverse(Code)}.

parse_tags(Tags) ->
    {ModList, TagList} = lists:foldl(fun(Tag, {M, T}) ->
        case parse_tag(Tag) of
        {mod, Module} -> {[Module | M], T};
        {tag, Name} -> {M, [Name | T]}
        end
    end, {[], []}, Tags),
    {lists:reverse(ModList), lists:reverse(TagList)}.

parse_tag(<<"mod:", Module/binary>>) -> {mod, Module};
parse_tag(Tag) -> {tag, Tag}.

atom_source(Name) ->
    <<$', Name/binary, $'>>.

a([]) ->
    <<"[]">>;
a([One]) ->
    [<<"[">>, One, <<"]">>];
a([One | More]) ->
    [<<"[">>, One, [[<<", ">>, Item] || Item <- More], <<"]">>].

b(Name) ->
    <<$<, $<, $", Name/binary, $", $>, $>>>.

s(I) ->
    N = integer_to_binary(I),
    <<$S, N/binary>>.

zipn(Start, List) ->
    Ns = lists:seq(Start, Start+length(List)-1),
    lists:zip(Ns, List).
